java 内存模型
    1：概述
        多任务和高并发是衡量一台计算机处理能力的重要指标之一。
        一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。
        在讨论Java内存模型和线程之前，先简单介绍一下硬件的效率与一致性。
    2：硬件的效率与一致性
        由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，
        所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：
            将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。
        基于个高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是引入了新的问题：缓存一致性问题-Cache Coherence。
        在多处理器系统中，每个处理器都有自己的高速缓存，而他们有共享同一主，所以需要一种协议可以保证数据的一致性。这类协议有MSI，MESI，MOSI，Dragon Protocol等。
        除此之外，为了使得处理器的内部运算单位能尽可能的被利用，处理器可能会对输入的代码进行乱序执行out of order Execution优化。处理器会在计算之后将对乱序执行的代码进行结果重组，保证结果的正确性。
        在java中JIT就有类似的指令重新排序的优化。

    3： JMM：java内存模型
        他的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与java编程时所说的变量不一样，指包括了实例字段、静态字段、构成数组对象的元素。但不包括局部变量与方法参数，后者是线程私有的不会共享。
        java内存模型规定了所有的变量都存储在主内存中，每条线程都还有自己的的工作内存，工作内存保存了该线程使用到的变量的到主内存的副本拷贝，线程对变量的所有操作，都必须在工作内存中进行，而不能直接读写主内存中的变量
        不同的线程之间无法直接访问对方的工作内存中的 变量，线程间变量的传递均需通过主内存来完成。这里应该有一个图
        内存件的交互：
            关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，jMMf提供了以下八种操作来完成：
                lock-锁定：作用于主内存的变量，把一个变量表示为一条线程独占状态。
                unlock：   作用于主内存变量，把一个处于锁定状态的变量释放，释放后的变量才可以被其他线程锁定。
                read    ： 作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
                load    ： 作用于工作内存变量，吧read操作得到的 变量放入工作内存的变量副本中。
                use     ： 作用于工作内存变量，吧工作内存的变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
                assign  ： 作用于工作内存变量，他把一个从执行引擎接收到的值赋值给工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
                store   ： 作用于工作内存变量，把工作内存中的一个变量的值传送到主内存中，以便虽有的write操作
                write   ： 作用于主内存变量，把store操作得到的值传送到主内存的变量中。

            JMM要求上述操作必须按照顺序执行，并没有保证连续执行。所以JMM还规定：
                不允许read和load，store和write单独出现
                不允许一个线程丢弃它最近assign的操作，即变量在工作内存中改变后必须同步到主内存中
                不允许一个线程无原因的把数据从工作内存同步到主内存（即未发生任何assign操作）
                一个变量在同一时刻只允许一条线程对其进行lock，lock和unlock必须成对出现。
                一个新的变量只能在主内存中产生，不允许工作内存直接使用一个未被初始化的变量loan或assign。即一个变量进行use和store之前必须先执行过了assign和load
                如果对一个变量执行lock，将会清空工作内存中此变量的值，在执行引擎中使用变量前需要重新执行load和assign初始化的值
                如果一个变量事先没有被lock锁定，不允许unlock，更不允许unlock其他线程lock的变量
                对一个变量执行unlock之前，必须事先把此变量同步到主内存中。store、write

        重排序
            编译器优化的重排序：在不改变单线程语义的前提下，可以重新安排语句的执行顺序。
            指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序
            内存系统的重排序： 由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行
            源代码--编译器--指令级--内存系统--最终执行指令序列

        为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：
            loadload---load1；loadload；load2 -- 确保Load1数据的装载，之前与load2以及所有后续装载指令的装载
            storestore-store1；storestore；store2--确保store1数据对其他处理器可见-刷新到内存，之前与store2以及所有后续存储指令的存储
            loadstore--load1；loadstore；store2  - 确保load1数据装载，之前与store2以及后续的存储指令刷新到内存
            storeload--store1；storeload；load   - 去报store1数据对处其他处理器变得可见，之前于load2以及后续装载指令的装载。本屏障会保证 之前的所有内存访问指令完成之后才执行该屏障之后的内存访问指令。

        同步包含互斥，它保证了一个线程在同步块之前或者同步块中的一个内存写入操作可以预知的方式对其他相同监视器的线程可见。我们释放监视器，这个监视器具有刷新缓冲到主内存的效果，因此该线程的写入能为其他线程所见。
        我们进入一个同步块之前需要获取监视器，监视器具有使本地缓存失效的功能，因此变量会从主存重新加载，于是对其他线程对共享变量的修改就对当前线程可见了。

        新的内存模型语义在内存操作（读取字段，写入字段，锁，解锁）以及其他线程的操作（start 和 join）中创建了一个部分排序，在这些操作中，一些操作被称为happen before其他操作。当一个操作在另外一个操作之前发生，第一个操作保证能够排到前面并且对第二个操作可见。这些排序的规则如下：
        线程中的每个操作happens before该线程中在程序顺序上后续的每个操作。
        解锁一个监视器的操作happens before随后对相同监视器进行锁的操作。
        对volatile字段的写操作happens before后续对相同volatile字段的读取操作。
        线程上调用start()方法happens before这个线程启动后的任何操作。
        一个线程中所有的操作都happens before从这个线程join()方法成功返回的任何其他线程。（注意思是其他线程等待一个线程的jion()方法完成，那么，这个线程中的所有操作happens before其他线程中的所有操作）
        这意味着：任何内存操作，这个内存操作在退出一个同步块前对一个线程是可见的，对任何线程在它进入一个被相同的监视器保护的同步块后都是可见的，因为所有内存操作happens before释放监视器以及释放监视器happens before获取监视器。
        其他如下模式的实现被一些人用来强迫实现一个内存屏障的，不会生效：
        synchronized (new Object()) {}
        这段代码其实不会执行任何操作，你的编译器会把它完全移除掉，因为编译器知道没有其他的线程会使用相同的监视器进行同步。要看到其他线程的结果，你必须为一个线程建立happens before关系。
        重点注意：对两个线程来说，为了正确建立happens before关系而在相同监视器上面进行同步是非常重要的。以下观点是错误的：当线程A在对象X上面同步的时候，所有东西对线程A可见，线程B在对象Y上面进行同步的时候，所有东西对线程B也是可见的。释放监视器和获取监视器必须匹配（也就是说要在相同的监视器上面完成这两个操作），否则，代码就会存在“数据竞争”。

        Final
            一个对象的final字段值是在他构造函数方法里面设置的。假设对象被正确的构造了，一旦对象被构造，在构造方法里面设置给final字段的值在没有同步的情况下对所有的其他线程可见。另外引用该字段的对象或者数组都将看到新的值。
            什么事正确的构造：意味着这个正在构造的对象的引用在构造期间没有被允许溢出--不要让其他线程看见在构造期间的对象引用。不要指派给一个静态字段，不要作为listener注册给其他对象等待。
            在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
            初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序
            public FinalFieldExample() { // bad!
              x = 3;
              y = 4;
              // bad construction - allowing this to escape
              global.obj = this;
            }

        String a = "hello2";
        final String b = "hello";
        String d = "hello";
        String c = b + 2;
        String e = d + 2;
        System.out.println((a == c));
        System.out.println((a == e));
        //一个是值，一个是指向该值的地址
            final String b = "hello"; 会在操作过程中将其转换为常量，直接读取常量池。
        只能在声明或者构造器中进行初始化
            读final域的重排序规则如下：
            在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。
            写
            JMM禁止编译器把final域的写重排序到构造函数之外。
            编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。

        volatile 用于线程间通讯的特殊字段。每次读都会看到其他线程写入该字段的最新值；并保证写好之后立刻刷新到主存，对其他线程可见。
        对volatile字段不能重排，而且对其周围的普通字段也不能重排，可以视为半个同步
        1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
        2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
        3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
        4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
        5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

        双重锁检查：
            volatile可以取消双重锁的检查模式问题，但是开销会有所上升，所以最好还是使用IODH

            使用IODH来实现多线程模式下的单例会更易读：

            private static class LazySomethingHolder {
              public static Something something = new Something();
            }

            public static Something getInstance() {
              return LazySomethingHolder.something;
            }
            这段代码是正确的，因为初始化是由static字段来保证的。如果一个字段设置在static初始化中，对其他访问这个类的线程来说是是能正确的保证它的可见性的。